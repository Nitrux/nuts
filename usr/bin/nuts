#!/usr/bin/env bash

# SPDX-License-Identifier: BSD-3-Clause
# Copyright 2023-2026 <Nitrux Latinoamericana S.C. <hello@nxos.org>>


# -- Exit on errors.

set -eu


# -- Set program name and version.

TOOL_NAME="Nitrux Update Tool System"
COMP_NAME="(Orchestrator Component)"
ORCH_VERSION="$(md5sum "$0" | cut -c -32)"
VENDOR='Nitrux Latinoamericana S.C.'
FECHA=$(date +%Y)


# -- Source shared functions.
# shellcheck source=/dev/null
. /usr/lib/nuts/functions


# -- Display version of running component.

puts_info "$TOOL_NAME $COMP_NAME version $ORCH_VERSION."


# -- Check if this is running as root and exit if not.

REQUIRE_ROOT=true

for arg in "$@"; do
    case "$arg" in
        -h|--help|-v|--version)
            REQUIRE_ROOT=false
            break
            ;;
    esac
done

if [ "$REQUIRE_ROOT" = true ]; then
    if [ "$(id -u)" -ne 0 ]; then
        puts_error "$TOOL_NAME is not running as root, quitting."
        exit 1
    else
        puts_success "$TOOL_NAME is running as root, continuing..."
    fi

    LOCK_FILE="/var/run/nuts.lock"
    exec 200>"$LOCK_FILE"
    if ! flock -n 200; then
        puts_error "Another instance of $TOOL_NAME is already running."
        exit 1
    fi
fi


# -- Check if any arguments are passed

if [ $# -eq 0 ]; then
    puts_error "No arguments provided to $TOOL_NAME, quitting."
    exit 1
fi


# -- Define the path of the configuration file.

CONFIG_FILE="/etc/nuts.conf"


# -- Load values from configuration file.
# -- Include fix for SC1090 – ShellCheck.

if [[ ! -f $CONFIG_FILE ]]; then
    puts_error "$TOOL_NAME configuration file not found!, quitting." 2>&1
    exit 1
else
    puts_success "$TOOL_NAME configuration file found, continuing..."
    # shellcheck source=/dev/null
    . "$CONFIG_FILE"
fi


# -- Use a log file.
# -- Everything below will go to the file nuts.log.

if [ -f "$NUTS_LOG" ]; then
    puts_info "$TOOL_NAME log file found, skipping..."
else
    puts_info "Creating a new log file, continuing..."
fi


# -- Component-specific variables.

DEBUG_WRAPPER=()

#   ====== START ======

# -- Flag parsing.

for CMD in "$@"; do
    case "$CMD" in
        -h | --help )
            print_message "$TOOL_NAME" \
                "" \
                "Description:" \
                "" \
                "     We designed the $TOOL_NAME utility to update [Nitrux OS](https://nxos.org/) and to provide a rollback backup option." \
                "    ⚠️ Important: We intended the $TOOL_NAME to work exclusively in Nitrux OS; using this utility in other distributions will break them or not work at all. Please do not open issues regarding this use case; they will be closed." \
                "" \
                "    Report bugs at: https://github.com/Nitrux/nuts/issues." \
                "" \
                "Flags:" \
                "    -h or --help                   Show this help." \
                "    -v or --version                Show the version." \
                "    -d or --debug                  Enable verbose output." \
                "    --use-main-branch              Defines the main branch of the $TOOL_NAME to download its components." \
                "    --use-development-branch       Defines the development branch of the $TOOL_NAME to download its components." \
                "" \
                "Operations:" \
                "    update            Update the currently installed root using the archive specified in nuts-query and creates a backup of the current root directory." \
                "    rescue            Restore the backup of the root partition in case of a partial update." \
                "    self-update       Update the $TOOL_NAME and its configuration file using the branch set in the configuration file." \
                "" \
                "Usage:" \
                "    sudo nuts <flag> (OPERATION)" \
                "" \
                "Examples:" \
                "    sudo nuts update" \
                "    sudo nuts -d self-update"
                
            exit
        ;;

        -v | --version )
            print_message "$TOOL_NAME" \
                "" \
                "Version: $ORCH_VERSION from branch '$NUTS_BRANCH'." \
                "" \
                "The license used for this file and its contents is: BSD-3-Clause." \
                "" \
                "Authors:" \
                "" \
                "    Copyright <2023-2026> <Uri Herrera <uri_herrera@nxos.org>>" \
                "    Copyright <2023> <Luis Lavaire <luis_lavaire@nxos.org>>" \
                "" \
                "(c) $FECHA Some Rights Reserved. Made by $VENDOR"
            exit
        ;;

        -d | --debug )
            set -x
            DEBUG_WRAPPER=(bash -x)
            shift
        ;;

        --use-main-branch )
            overlay_ch sed -i 's+NUTS_BRANCH=development+NUTS_BRANCH=main+g' /etc/nuts.conf
            puts_success "$TOOL_NAME is using the following git branch: main"
            puts_info "Reboot to load changes into overlay. Bye."
            exit
        ;;

        --use-development-branch )
            overlay_ch sed -i 's+NUTS_BRANCH=main+NUTS_BRANCH=development+g' /etc/nuts.conf
            puts_success "$TOOL_NAME is using the following git branch: development"
            puts_info "Reboot to load changes into overlay. Bye."
            exit
        ;;

        update | rescue | self-update )
            OPERATION="$CMD"
        ;;

        * )
            puts_error "Unknown flag or operation: «$CMD», quitting."
            puts_info "Use «-h or --help» to display the help."
            exit 1
        ;;
    esac
done


( 
    case "$OPERATION" in
        '' )
            puts_error "No operation specified (use -h to see a list of operations)."
            exit 1
        ;;

        update )

            # -- Step 0: Run checks before actually doing anything.

            # -- Check Internet and GitHub connectivity.

            check_connectivity


            # -- Update process begins.
            # -- The update process is divided into two sub-processes: the first is backup, and the second is the actual update.

            # -- Download the nuts-query file from our repository and then use the checksum listed in the file to compare its values.
            # -- This file is always downloaded to a temporary directory, as there's no reason to keep it.
            # -- Overwrite the file if it already exists.

            INFO_FILE="/tmp/nuts-query.info"

            if [[ ! -f "$INFO_FILE" ]]; then
                puts_info "Downloading nuts-query.info, continuing..."
            else
                puts_info "Found nuts-query.info, overwriting..."
                rm -f "$INFO_FILE"
            fi

            dl_file "https://raw.githubusercontent.com/Nitrux/nuts/$NUTS_BRANCH/tmp/nuts-query.info" > /dev/null 2>&1


            # -- Make a comparison of the current installation version against the minimum target for upgrade.
            # -- This way, we know that the user is running this tool on an installation that we can upgrade; thus, this tool works as intended.
            # -- If the check matches, it means there's an update.
            # -- if the check doesn't match, it means there's no update.
            
            if [ -f /etc/lsb-release ]; then
                # shellcheck source=/dev/null
                . /etc/lsb-release
            else
                puts_error "/etc/lsb-release not found. Cannot determine system version."
                exit 1
            fi

            MINTARGET=$(grep '^MINTARGET=' /tmp/nuts-query.info | cut -d'=' -f2)
            
            MINTARGET="${MINTARGET%\"}"
            MINTARGET="${MINTARGET#\"}"

            TARGET_DIST="nitrux"

            if [[ "$DISTRIB_RELEASE" != "$MINTARGET" ]]; then
                puts_info "No update is available for ${TARGET_DIST^} $DISTRIB_RELEASE. Bye."
                exit 0
            else
                puts_info "An update is available for ${TARGET_DIST^} $DISTRIB_RELEASE, continuing..."
            fi


            # -- Create working directories in /home since this partition will likely have more space than the root partition.

            DIRECTORIES=("$NUTS_DIR_BAK" "$NUTS_DIR_XFS" "$NUTS_DIR_DLS" "$NUTS_DIR_SQS")
            CREATED_COUNT=0

            for DIR in "${DIRECTORIES[@]}"; do
                if [[ ! -d "$DIR" ]]; then
                    if ! mkdir -p "$DIR"; then
                        puts_error "Failed to create directory '$DIR', quitting."
                        exit 1
                    fi
                    CREATED_COUNT=$((CREATED_COUNT+1))
                fi
            done

            if [ "$CREATED_COUNT" -gt 0 ]; then
                puts_info "Initialized $CREATED_COUNT missing working directories."
            fi


            # -- Step 1: Backup sub-process.

            # -- This process begins as a step before doing an update.
            # -- Backup files only exist when updating; the user can't ask the utility to create them on demand.
            # -- This utility will create a backup of the root partition.

            # -- Create a backup of the partition using xfsdump to later use it during a rescue operation from a Live session.
            # -- By the way, only *one* backup file is created, then compress the backup file using zstd. We must delete the original file after compression.
            # -- This backup is created outside of the chroot because xfsdump relies on /etc/mtab, and that file is unavailable when using overlayroot-chroot.
            # -- Since the XFS backup is a "full-backup" (level 0), it won't support incremental updates.

            ROOT_PARTITION=$(findmnt -n -o SOURCE /media/root-ro 2>/dev/null || true)

            if [ -z "$ROOT_PARTITION" ]; then
                ROOT_PARTITION=$(findmnt -n -o SOURCE / 2>/dev/null || true)
            fi

            if [ -z "$ROOT_PARTITION" ]; then
                puts_error "Could not resolve the root device from mount points. Quitting."
                exit 1
            fi

            ROOT_PARTITION_LABEL=$(blkid -o value -s LABEL "$ROOT_PARTITION" 2>/dev/null || true)
            ROOT_PARTITION_FS=$(blkid -o value -s TYPE "$ROOT_PARTITION" 2>/dev/null || true)

            if [ -z "$ROOT_PARTITION_LABEL" ]; then
                puts_error "Resolved root device $ROOT_PARTITION has no label, quitting."
                exit 1
            fi

            if [[ "$ROOT_PARTITION_FS" != "xfs" ]]; then
                puts_error "The filesystem of $ROOT_PARTITION_LABEL ($ROOT_PARTITION) is not XFS, quitting."
                exit 1
            fi


            # -- Check for duplicate NX_ROOT labels to prevent backing up to the wrong drive.

            LABEL_COUNT=$(blkid -o device -t LABEL="$ROOT_PARTITION_LABEL" 2>/dev/null | wc -l)

            if [ "$LABEL_COUNT" -gt 1 ]; then
                puts_warning "Detected $LABEL_COUNT devices with label $ROOT_PARTITION_LABEL; backing up active root device $ROOT_PARTITION."
            fi

            XFS_BACKUP_FILE="$NUTS_DIR_XFS/xfs-backup.xfs"
            COMPRESSED_XFS_BACKUP="$XFS_BACKUP_FILE.zst"
            ZSTD_COMP_THREADS=$(nproc)

            if [[ -f "$COMPRESSED_XFS_BACKUP" ]]; then  
                puts_info "Backup of $ROOT_PARTITION_LABEL found, skipping..."
            else
                puts_warning "Backup of $ROOT_PARTITION_LABEL not found, creating it..."

                xfsdump -l0 -L "Nitrux_Update_Tool_System-XFS_Backup" -M "NX_BAK-Vol-1" -f "$XFS_BACKUP_FILE" "$ROOT_PARTITION" > /dev/null 2>&1 &
                spinner "$!"

                puts_info "Using $ZSTD_COMP_THREADS threads for backup compression, please wait..."

                zstd -T"$ZSTD_COMP_THREADS" -3 "$XFS_BACKUP_FILE" -o "$COMPRESSED_XFS_BACKUP"

                rm -f "$XFS_BACKUP_FILE"
                md5sum "$COMPRESSED_XFS_BACKUP" > "$NUTS_DIR_XFS/xfs-backup.md5sum"
                sync
                puts_success "$ROOT_PARTITION_LABEL backup has been created, continuing..."
            fi


            # -- Step 2: Actual Update sub-process.

            # -- Check for the overlayroot-chroot executable and mounts using OverlayFS.
            # -- Quit if either of these checks fails.

            OVERLAYROOT_CHROOT="/usr/sbin/overlayroot-chroot"

            if [[ ! -f "$OVERLAYROOT_CHROOT" ]]; then
                puts_error "Can't find overlayroot-chroot, quitting."
                exit 1
            else
                puts_info "Found overlayroot-chroot, continuing..."
            fi

            if ! mount | grep -q "overlayroot"; then
                puts_error "No OverlayFS mounts in use, quitting."
                puts_warning "$TOOL_NAME requires OverlayFS to be active."
                exit 1
            else
                puts_info "OverlayFS mounts in use, continuing..."
            fi


            # -- Enter the Matrix, err, I mean, the overlay.
            # -- After using overlay_ch, it's essential to remember that **EVERY COMMAND IS RUNNING AS ROOT AND IN THE LOWER DIRECTORY OF THE OVERLAY**.
            # -- Run nuts-cru to perform the backup and update.
            # -- Always download the latest component. The component will remain in the filesystem after use; however, when the user executes this <operation> again, it will be deleted and re-downloaded.
            # -- Download nuts-query.info to the chroot because we initially downloaded it to the overlay.

            overlay_ch mount -t devtmpfs dev /dev
            overlay_ch find /usr/bin -type f -name "nuts-cru" -exec rm -v {} \; > /dev/null 2>&1
            overlay_ch axel -o /usr/bin -c -n 10 "https://raw.githubusercontent.com/Nitrux/nuts/$NUTS_BRANCH/tmp/nuts-cru" > /dev/null 2>&1
            overlay_ch chmod +x /usr/bin/nuts-cru
            overlay_ch find /tmp -type f -name "nuts-query.info" -exec rm -v {} \; > /dev/null 2>&1
            overlay_ch axel -o /tmp -c -n 10 "https://raw.githubusercontent.com/Nitrux/nuts/$NUTS_BRANCH/tmp/nuts-query.info" > /dev/null 2>&1
            overlay_ch "${DEBUG_WRAPPER[@]}" nuts-cru 2>&1 | \
                grep --line-buffered -v -E "mount: /media/root-ro: mount point is busy|dmesg\(1\) may have more information|ERROR: Note that \[/media/root-ro\] is still mounted read/write" || true


            # -- Ensure we still exit with error if nuts-cru failed (since the pipe swallows the exit code).

            if [ "${PIPESTATUS[0]}" -ne 0 ]; then
                exit "${PIPESTATUS[0]}"
            fi


            # -- Trigger the reboot in a background subshell that survives the script exit.
            # -- We use nohup or parentheses to detach it, ensuring 'nuts' exits cleanly first.

            REBOOT_SECONDS=30

            ( 
                sleep "$REBOOT_SECONDS"


                # -- EMERGENCY SYNC: Use Magic SysRq 's' to force immediate flush of dirty buffers.
                # -- This works even if userspace is frozen or dying.

                echo 1 > /proc/sys/kernel/sysrq 2>/dev/null
                echo s > /proc/sysrq-trigger


                # -- Standard sync for good measure.

                sync
                
                reboot 
            ) &


        # -- Exit cleanly immediately.

        exit 0
        ;;


        rescue )

            # -- Step 0: Rescue Process.

            # -- The Rescue Process does not require using overlayroot-chroot.

            # -- Rescue exists in case of a partial update causing the root to be unusable, i.e., the user can't access the GUI or, worse, a TTY.
            # -- With that being the case, this <operation> allows the user to restore the root partition from a Live session.

            # -- Automatically check if this utility is running in a Live session. Calamares is an easy check as it's only available in a Live session.
            # -- Online in-place restoration is intentionally not supported because it can corrupt a running system.
            # -- If the check returns that this utility is not running from a Live session, exit.

            ROOT_PARTITION=$(findfs LABEL=NX_ROOT 2>/dev/null || true)


            # -- Fallback if NX_ROOT label isn't found.

            if [ -z "$ROOT_PARTITION" ]; then
                puts_error "Partition with label NX_ROOT not found, quitting."
                exit 1
            fi

            ROOT_PARTITION_LABEL=$(blkid -o value -s LABEL "$ROOT_PARTITION")
            ROOT_PARTITION_FS=$(blkid -o value -s TYPE "$ROOT_PARTITION")

            HOME_PARTITION=$(findfs LABEL=NX_HOME 2>/dev/null || true)
            HOME_PARTITION_LABEL=$(blkid -o value -s LABEL "$HOME_PARTITION")
            NUTS_USER="nitrux"

            if [ -z "$HOME_PARTITION" ]; then
                puts_error "Partition with label NX_HOME not found, quitting."
                exit 1
            fi

            if [[ "$ROOT_PARTITION_FS" != "xfs" ]]; then
                puts_error "The filesystem of $ROOT_PARTITION_LABEL is not XFS, quitting."
                exit 1
            fi


            # -- Check for duplicate NX_ROOT labels to prevent restoring to the wrong drive.
            
            LABEL_COUNT="$(blkid -o device -t LABEL=NX_ROOT | wc -l)"

            if [ "$LABEL_COUNT" -gt 1 ]; then
                puts_error "Duplicate NX_ROOT partition labels detected!"
                puts_error "We found $LABEL_COUNT devices with the label 'NX_ROOT'."
                puts_error "Please disconnect the external/secondary drive to ensure safe restoration."
                exit 1
            fi

            if [[ ! -x "/usr/bin/calamares" ]]; then
                puts_warning "Only use this option from a Live session."
                exit 0
            fi

            if mountpoint -q "/media/$NUTS_USER/NX_ROOT"; then
                puts_info "/media/$NUTS_USER/NX_ROOT is already mounted. Unmounting..."
                umount "/media/$NUTS_USER/NX_ROOT"
            fi

            if mountpoint -q "/media/$NUTS_USER/NX_HOME"; then
                puts_info "/media/$NUTS_USER/NX_HOME is already mounted. Unmounting..."
                umount "/media/$NUTS_USER/NX_HOME"
            fi

            mkdir -p "/media/$NUTS_USER/NX_ROOT" "/media/$NUTS_USER/NX_HOME"

            puts_info "Mounting: $ROOT_PARTITION_LABEL to /media/$NUTS_USER/NX_ROOT"
            mount -t auto "$ROOT_PARTITION" "/media/$NUTS_USER/NX_ROOT"

            puts_info "Mounting: $HOME_PARTITION_LABEL to /media/$NUTS_USER/NX_HOME"
            mount -t auto "$HOME_PARTITION" "/media/$NUTS_USER/NX_HOME"

            COMPRESSED_XFS_BACKUP="/media/$NUTS_USER/NX_HOME/.nuts/xfs/xfs-backup.xfs.zst"
            XFS_BACKUP_CHECKSUM_FILE="/media/$NUTS_USER/NX_HOME/.nuts/xfs/xfs-backup.md5sum"
            DECOMPRESSED_XFS_BACKUP="/media/$NUTS_USER/NX_HOME/.nuts/xfs/xfs-backup.xfs"

            if [[ ! -f "$COMPRESSED_XFS_BACKUP" ]]; then
                puts_error "XFS backup file $COMPRESSED_XFS_BACKUP not found, quitting."
                exit 1
            fi

            if [[ ! -f "$XFS_BACKUP_CHECKSUM_FILE" ]]; then
                puts_error "XFS backup checksum file $XFS_BACKUP_CHECKSUM_FILE not found, quitting."
                exit 1
            fi

            BACKUP_SUM=$(md5sum "$COMPRESSED_XFS_BACKUP" | awk '{print $1}')
            GEN_BAK_SUM=$(tail -n 1 "$XFS_BACKUP_CHECKSUM_FILE" | awk '{print $1}')

            if [[ "$BACKUP_SUM" == "$GEN_BAK_SUM" ]]; then
                puts_info "XFS backup checksum matches, continuing..."
            else
                puts_error "XFS backup checksum does not match, quitting."
                exit 1
            fi

            puts_info "Running $TOOL_NAME from a Live session, proceed with restoration of $ROOT_PARTITION_LABEL, continuing..."

            TARGET_MOUNT="/media/$NUTS_USER/NX_ROOT"

            if mountpoint -q "$TARGET_MOUNT"; then
                puts_warning "Wiping $TARGET_MOUNT to ensure a clean restoration..."
                find "$TARGET_MOUNT" -mindepth 1 -delete
            else
                puts_error "Target $TARGET_MOUNT is not mounted, cannot proceed safely."
                exit 1
            fi

            zstd -d -f -o "$DECOMPRESSED_XFS_BACKUP" "$COMPRESSED_XFS_BACKUP"
            xfsrestore -f "$DECOMPRESSED_XFS_BACKUP" "$TARGET_MOUNT"

            puts_success "$ROOT_PARTITION_LABEL has been restored."
            rm -f "$DECOMPRESSED_XFS_BACKUP"

            unmount_directory "/media/$NUTS_USER/NX_ROOT" || { puts_error "Failed to unmount NX_ROOT, quitting."; exit 1; }
            unmount_directory "/media/$NUTS_USER/NX_HOME" || { puts_error "Failed to unmount NX_HOME, quitting."; exit 1; }


        # -- Exit cleanly immediately.

        exit 0
        ;;


        self-update )

            # -- Step 0: Self-Update Process.

            # -- Check Internet and GitHub connectivity.

            check_connectivity


            # -- Check for the overlayroot-chroot executable and mounts using OverlayFS.
            # -- Quit if either of these checks fails.

            OVERLAYROOT_CHROOT="/usr/sbin/overlayroot-chroot"

            if [[ ! -f "$OVERLAYROOT_CHROOT" ]]; then
                puts_error "Can't find overlayroot-chroot, quitting."
                exit 1
            else
                puts_info "Found overlayroot-chroot, continuing..."
            fi

            if ! mount | grep -q "overlayroot"; then
                puts_error "No OverlayFS mounts in use, quitting."
                puts_warning "$TOOL_NAME requires OverlayFS to be active."
                exit 1
            else
                puts_info "OverlayFS mounts in use, continuing..."
            fi


            # -- Display branch used to update.

            puts_info "Using branch '$NUTS_BRANCH' to update $TOOL_NAME, continuing..."


            # -- Whenever we upload a new version of the utility to the repository, users use this <operation> to update it. This operation also updates the configuration file.
            # -- After using overlay_ch, it's essential to remember that **EVERY COMMAND IS RUNNING AS ROOT AND IN THE LOWER DIRECTORY OF THE OVERLAY**.
            # -- Always download the latest component. The component will remain in the filesystem after use; however, when the user executes this <operation> again, it will be deleted and re-downloaded.

            overlay_ch mount -t devtmpfs dev /dev
            overlay_ch find /usr/bin -type f -name "nuts-sup" -exec rm -v {} \; > /dev/null 2>&1
            overlay_ch axel -o /usr/bin -c -n 10 "https://raw.githubusercontent.com/Nitrux/nuts/$NUTS_BRANCH/tmp/nuts-sup" > /dev/null 2>&1
            overlay_ch chmod +x /usr/bin/nuts-sup
            overlay_ch "${DEBUG_WRAPPER[@]}" nuts-sup 2>&1 | \
                grep --line-buffered -v -E "mount: /media/root-ro: mount point is busy|dmesg\(1\) may have more information|ERROR: Note that \[/media/root-ro\] is still mounted read/write" || true


            # -- Ensure we still exit with error if nuts-sup failed (since the pipe swallows the exit code).

            if [ "${PIPESTATUS[0]}" -ne 0 ]; then
                exit "${PIPESTATUS[0]}"
            fi


        # -- Exit cleanly immediately.

        exit 0
        ;;


        # -- Exit if not valid operation was specified.
                
        *)
            puts_error "No valid operation specified, quitting."
            puts_info "Use «-h or --help» to display the help."
            exit 1
        ;;
    esac
) 2>&1 | tee -a "$NUTS_LOG"

#   ====== END ======
