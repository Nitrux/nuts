#!/usr/bin/env bash

# SPDX-License-Identifier: BSD-3-Clause
# Copyright 2023-2026 <Nitrux Latinoamericana S.C. <hello@nxos.org>>


# -- Exit on errors.

set -eu


# -- Set program name and version.

TOOL_NAME="Nitrux Update Tool System"
COMP_NAME="(Update Component)"
CRU_VERSION="$(md5sum "$0" | cut -c -32)"


# -- Source shared functions safely.
# -- If the library is missing (first run on old system), define fallbacks so the script doesn't crash.

if [ -f "/usr/lib/nuts/functions" ]; then
    # shellcheck source=/dev/null
    . "/usr/lib/nuts/functions"
else
    puts_info()    { printf 'Info: %s\n' "$*" >&2; }
    puts_success() { printf 'Success: %s\n' "$*" >&2; }
    puts_warning() { printf 'Warning: %s\n' "$*" >&2; }
    puts_error()   { printf 'Error: %s\n' "$*" >&2; }
    
    spinner() {
        local pid=$1
        while kill -0 "$pid" 2>/dev/null; do
            printf '.'
            sleep 0.5
        done
        printf '\n'
    }
    
    unmount_directory() {
        if mountpoint -q "$1"; then umount "$1"; fi
    }
    
    dl_file() {
        if ! axel -n 10 -o "/tmp" "$1"; then return 1; fi
    }
fi


# -- Display version of running component.

puts_info "$TOOL_NAME $COMP_NAME version $CRU_VERSION."


# -- Define the path of the nuts configuration file.

CONFIG_FILE="/etc/nuts.conf"


# -- Load values from configuration file.
# -- Include fix for SC1090 – ShellCheck.

if [[ ! -f $CONFIG_FILE ]]; then
    puts_error "$TOOL_NAME configuration file not found!, quitting." 2>&1
    exit 1
else
    puts_success "$TOOL_NAME configuration file found, continuing..."
    # shellcheck source=/dev/null
    . "$CONFIG_FILE"
fi


# -- Component-specific functions.

cleanup() {
    local exit_code=$?
    
    unmount_directory "$NUTS_DIR_SQS"
    unmount_directory "/home"
    unmount_directory "/var/lib"

    if [ $exit_code -ne 0 ]; then
        puts_error "Component exited unexpectedly with code $exit_code."
    fi
}

trap cleanup EXIT

#   ====== START ======

# -- Mount NX_HOME partition.
# -- When entering the chroot, only the root partition is mounted, but that's likely not to have enough storage.
# -- So, let's use the /home partition. We're discovering NX_HOME from the partition's LABEL.

HOME_PARTITION=$(findfs LABEL=NX_HOME)

if ! mountpoint -q /home; then
    puts_info "Mounting: $HOME_PARTITION to /home"
    mount -t auto "$HOME_PARTITION" /home
else
    puts_info "/home is already mounted."
fi


# -- Mount NX_VAR_LIB partition.
# -- We need to mount this partition so that when nuts-ccu runs update-grub, the GRUB menu is correctly updated.

if ! VAR_LIB_PARTITION=$(findfs LABEL=NX_VAR_LIB 2>/dev/null); then
    puts_error "Cannot find partition with label NX_VAR_LIB. This partition is required for GRUB updates, quitting."
    exit 1
fi

if mountpoint -q /var/lib; then
    current_src=$(findmnt -n -o SOURCE --target /var/lib)
    if [ "$current_src" = "$VAR_LIB_PARTITION" ]; then
        puts_info "/var/lib is already mounted."
    else
        puts_warning "/var/lib is mounted from $current_src, expected $VAR_LIB_PARTITION. Remounting..."
        umount /var/lib
        mount -t auto "$VAR_LIB_PARTITION" /var/lib
    fi
else
    puts_info "Mounting: $VAR_LIB_PARTITION to /var/lib"
    mount -t auto "$VAR_LIB_PARTITION" /var/lib
fi


# -- Create working directories in /home since this partition will likely have more space.

DIRECTORIES=("$NUTS_DIR_XFS" "$NUTS_DIR_DLS" "$NUTS_DIR_SQS")
CREATED_COUNT=0

for DIR in "${DIRECTORIES[@]}"; do
    if [[ ! -d "$DIR" ]]; then
        if ! mkdir -p "$DIR"; then
            puts_error "Failed to create directory '$DIR', quitting."
            exit 1
        fi
        CREATED_COUNT=$((CREATED_COUNT+1))
    fi
done

if [ "$CREATED_COUNT" -gt 0 ]; then
    puts_info "Initialized $CREATED_COUNT missing working directories."
fi

puts_success "All required directories exist, continuing..."


# -- Download the OTA SquashFS with axel if it doesn't exist. Use the list of mirrors from the query file.
# -- If the OTA file exists but it doesn't match the checksum in nuts-query.info, delete it and try again. Ends cleanly if all mirrors are exhausted.

OTA_FILE="$NUTS_DIR_DLS/nuts-ota.squashfs"
MIRROR_LIST=$(grep '^MIRRORLIST=' /tmp/nuts-query.info | sed -e 's/[^=]*=//' -e 's/,/ /g')
NQ_OTA_SUM=$(grep -oP '(?<=^OTASUM=)[a-f0-9]{32}' /tmp/nuts-query.info)

DOWNLOAD_SUCCESS=false

if [[ -f "$OTA_FILE" ]]; then
    puts_info "OTA file found, verifying checksum..."
    LOCAL_OTA_SUM=$(md5sum "$OTA_FILE" | awk '{ print $1 }')
    if [[ "$LOCAL_OTA_SUM" == "$NQ_OTA_SUM" ]]; then
        puts_success "OTA file checksum matches, skipping download."
        DOWNLOAD_SUCCESS=true
    else
        puts_warning "OTA file checksum mismatch, deleting file and re-downloading..."
        rm -f "$OTA_FILE"
    fi
else
    puts_warning "OTA file not found! Attempting to download..."
fi

if [[ "$DOWNLOAD_SUCCESS" = false ]]; then
    for MIRROR_URL in $MIRROR_LIST; do
        puts_info "Trying mirror URL: $MIRROR_URL"
        axel -q -n 10 -o "$OTA_FILE" "$MIRROR_URL" &
        axel_pid=$!

        while kill -0 "$axel_pid" 2>/dev/null; do
            if [ -f "$OTA_FILE" ]; then
                current_size=$(du -h "$OTA_FILE" | awk '{print $1}')
                printf "\033[34mInfo:\033[0m Downloaded: %-10s\r" "$current_size" > /dev/tty
            fi
            sleep 1
        done
        printf "\n" > /dev/tty

        if ! wait "$axel_pid"; then
            puts_warning "Download from $MIRROR_URL failed. Trying the next mirror..."
            continue
        fi

        LOCAL_OTA_SUM=$(md5sum "$OTA_FILE" | awk '{ print $1 }')
        if [[ "$LOCAL_OTA_SUM" == "$NQ_OTA_SUM" ]]; then
            puts_success "OTA file downloaded and verified, continuing..."
            DOWNLOAD_SUCCESS=true
            break
        else
            puts_warning "Checksum mismatch for $MIRROR_URL. Deleting file and trying next mirror..."
            rm -f "$OTA_FILE"
        fi
    done
fi

if [[ "$DOWNLOAD_SUCCESS" = false ]]; then
    puts_error "Download failed from all mirrors or checksums didn't match. Quitting."
    exit 1
fi


# -- Mount the OTA SquashFS.

mount "$NUTS_DIR_DLS"/nuts-ota.squashfs "$NUTS_DIR_SQS"


# -- Specify the data archive when upgrading using the same version set as the minimum target in nuts-query.
# -- We assume that VAR_DATA_TARGET will match MINTARGET in nuts-query.conf since we've already done a test in the main component.

CURRENT_DIST=$(awk -F'=' '/VERSION_CODENAME/{print $NF}' /usr/lib/os-release)

puts_info "Updating ${CURRENT_DIST^}, continuing..."

APPIMAGE_URL="https://raw.githubusercontent.com/Nitrux/storage/master/Other/AppImages/dpkg-1.22.21-x86_64.AppImage"
AIFILE_DL_PATH="/tmp/dpkg-1.22.21-x86_64.AppImage"
EXTRACT_DIR="/tmp/pkgman-extracted"
AIPKG_MANAGER="$EXTRACT_DIR/squashfs-root/AppRun"

VAR_DATA_TARGET=$(grep 'MINTARGET=' /tmp/nuts-query.info | cut -d'=' -f2)
VAR_DATA_URL="https://raw.githubusercontent.com/Nitrux/storage/master/Other/var-lib-dpkg-$VAR_DATA_TARGET.tar.xz"
TARFILE_DL_PATH="/tmp/var-lib-dpkg-$VAR_DATA_TARGET.tar.xz"

if [[ -f "$AIPKG_MANAGER" ]]; then
    puts_info "Extracted OTA tooling already exists, skipping download, continuing..."
else
    puts_info "Downloading OTA tooling..."
    
    if dl_file "$APPIMAGE_URL"; then
        if [[ $(file --mime-type -b "$AIFILE_DL_PATH") == "application/x-pie-executable" ]]; then
            puts_info "Extracting OTA tooling..."
            mkdir -p "$EXTRACT_DIR"
            chmod +x "$AIFILE_DL_PATH"
            (cd "$EXTRACT_DIR" && "$AIFILE_DL_PATH" --appimage-extract > /dev/null 2>&1)
            if [[ -x "$AIPKG_MANAGER" ]]; then
                puts_success "OTA tooling extracted successfully, continuing..."
            else
                puts_error "Extraction failed or AppRun not found, quitting."
                rm -rf "$EXTRACT_DIR" "$AIFILE_DL_PATH"
                exit 1
            fi
        else
            puts_error "Downloaded file is not a valid file, quitting."
            rm -f "$AIFILE_DL_PATH"
            exit 1
        fi
    else
        puts_error "Failed to download OTA tooling, quitting."
        rm -f "$AIFILE_DL_PATH"
        exit 1
    fi
fi

ln -svf "$AIPKG_MANAGER" /usr/bin/dpkg > /dev/null 2>&1

DPKG_TOOLS=(
    "dpkg-deb"
    "dpkg-divert"
    "dpkg-query"
    "dpkg-realpath"
    "dpkg-split"
    "dpkg-statoverride"
    "dpkg-trigger"
    "dpkg-maintscript-helper"
    "update-alternatives"
)

for tool in "${DPKG_TOOLS[@]}"; do
    tool_path="$EXTRACT_DIR/squashfs-root/usr/bin/$tool"
    if [[ -f "$tool_path" ]]; then
        ln -svf "$tool_path" "/usr/bin/$tool" > /dev/null 2>&1
    fi
done

if [ -d "$EXTRACT_DIR/squashfs-root/usr/share/dpkg" ]; then
    mkdir -p /usr/share
    ln -svf "$EXTRACT_DIR/squashfs-root/usr/share/dpkg" /usr/share/dpkg > /dev/null 2>&1
fi


# -- Download var archive.

puts_info "Fetching system data archive, continuing..."

[[ -f "$TARFILE_DL_PATH" ]] && rm "$TARFILE_DL_PATH"

if dl_file "$VAR_DATA_URL" && \
   mkdir -p /var/lib/dpkg && \
   (cd / && tar -xf "$TARFILE_DL_PATH" >/dev/null 2>&1) && \
   [ -f /var/lib/dpkg/status ]; then
    puts_success "Data archive downloaded and extracted successfully, continuing..."
else
    puts_error "Failed to download or extract the data archive, quitting."
    [[ -f "$TARFILE_DL_PATH" ]] && rm "$TARFILE_DL_PATH"
    exit 1
fi


# -- Apply OTA update.

puts_info "Proceed to apply OTA update, continuing..."

if (
    export DEBIAN_FRONTEND=noninteractive

    export TMPDIR=/tmp
    mkdir -p /tmp
    chmod 1777 /tmp

    puts_info "Phase 1: Unpacking OTA content, please wait..."

    SEARCH_PATHS=("${NUTS_DIR_SQS}/ota/updates/")

    if [ "$(get_gpu_manufacturer)" == "NVIDIA" ] && [ -d "${NUTS_DIR_SQS}/ota/nvidia/" ]; then
        puts_info "NVIDIA hardware detected. Enabling NVIDIA-specific updates, please wait..."
        SEARCH_PATHS+=("${NUTS_DIR_SQS}/ota/nvidia/")
    fi

    if ! find "${SEARCH_PATHS[@]}" -name '*.deb' -print0 | \
        xargs -0 -n 120 "$AIPKG_MANAGER" --force-all --unpack >/dev/null 2>&1; then
        puts_error "Failed to unpack OTA content, quitting."
        exit 1
    fi

    puts_info "Phase 2: Configuring OTA content (repeat until clean), please wait..."

    max_passes=15
    pass=1
    last_audit=""

    while :; do
        puts_info "Configuration pass ${pass}/${max_passes}..."
        "$AIPKG_MANAGER" --force-all --configure -a >/dev/null 2>&1 || true

        audit_out=$("$AIPKG_MANAGER" --audit 2>/dev/null || true)

        if [ -z "$audit_out" ]; then
            puts_success "OTA content configuration completed, continuing..."
            exit 0
        fi

        if [ "$audit_out" = "$last_audit" ]; then
            puts_error "$TOOL_NAME $COMP_NAME backend did not converge (no progress detected)."
            puts_error "dpkg --audit output:"
            printf '%s\n' "$audit_out"
            exit 1
        fi

        if [ "$pass" -ge "$max_passes" ]; then
            puts_error "$TOOL_NAME $COMP_NAME backend did not converge after ${max_passes} passes."
            puts_error "dpkg --audit output:"
            printf '%s\n' "$audit_out"
            exit 1
        fi

        last_audit="$audit_out"
        pass=$((pass + 1))
        sleep 1
    done
); then
    puts_success "OTA update process completed successfully, continuing..."
else
    puts_error "Failed to apply OTA update, quitting."
    exit 1
fi

[[ -d "$EXTRACT_DIR" ]] && rm -rf "$EXTRACT_DIR" > /dev/null 2>&1

rm -f /usr/bin/dpkg \
      /usr/bin/dpkg-{deb,divert,query,realpath,split,statoverride,trigger,maintscript-helper} \
      /usr/bin/update-alternatives > /dev/null 2>&1

unmount_directory "$NUTS_DIR_SQS"


# -- Clean up the updated root after updating.

puts_info "Calling the $TOOL_NAME $COMP_NAME Cleanup Crew, continuing..."

CLEANUP_SCRIPT_URL="https://raw.githubusercontent.com/Nitrux/nuts/$NUTS_BRANCH/tmp/nuts-ccu"

if dl_file "$CLEANUP_SCRIPT_URL"; then
    if chmod +x /tmp/nuts-ccu && bash /tmp/nuts-ccu >/dev/null 2>&1; then
        puts_success "Cleanup script executed without problems, continuing..."
    else
        puts_error "Something failed in the cleanup script; reboot and try to update again, quitting."
        exit 1
    fi
else
    puts_error "Failed to download the cleanup script, quitting."
    exit 1
fi

rm -f /tmp/nuts-ccu


# -- Display dialog to notify users of software management policy.

for n in apt apt-cache apt-cdrom apt-config apt-get apt-mark; do
    ln -sf /usr/bin/nx-pkgmgr-policy "/usr/bin/$n"
done

for n in \
    dpkg dpkg-deb dpkg-divert dpkg-maintscript-helper dpkg-query dpkg-realpath \
    dpkg-split dpkg-statoverride dpkg-trigger \
    dpkg-architecture dpkg-buildapi dpkg-buildflags dpkg-buildpackage \
    dpkg-buildtree dpkg-checkbuilddeps dpkg-distaddfile \
    dpkg-genbuildinfo dpkg-genchanges dpkg-gencontrol dpkg-gensymbols \
    dpkg-mergechangelogs dpkg-name dpkg-parsechangelog \
    dpkg-scanpackages dpkg-scansources dpkg-shlibdeps dpkg-source dpkg-vendor
do
    ln -sf /usr/bin/nx-pkgmgr-policy "/usr/bin/$n"
done


# -- **DO NOT PERFORM ANY FILE OPERATION AFTER THIS POINT**

sync

puts_success "${CURRENT_DIST^} has been updated."


# -- Display message to the user.

puts_warning "⚠️ Important: Do not continue using the system in this state. Reboot to load the changes into the overlay and finalize the update."


# -- Try to exit the chroot cleanly.

unmount_directory "/home" > /dev/null 2>&1
unmount_directory "/var/lib" > /dev/null 2>&1

#   ====== END ======
